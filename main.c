#include <stdio.h>
#include <stdlib.h>
// This include pulls in everything you need to develop with OpenCL in OS X.
#include <OpenCL/opencl.h>
// Include the header file generated by Xcode. This header file contains the
// kernel block declaration. // 1
#include "mykernel.cl.h"
// Hard-coded number of values to test, for convenience.
#include <time.h>

#include <vector>
#include <fstream>
#include <string>
#include <sstream>
#include <iostream>

using namespace std;


int main (int argc, const char * argv[]) {
    int numNodes = 100000;
    vector<vector<int > >  adjM(numNodes);
    
    ifstream infile("/Users/yixing/Desktop/links-simple-sorted.txt", std::ifstream::in);
    int numEdges = 0;
    int source,destination,destination2;
    string des,STRING;
    //int norm_col_factor[matrix_size];
    
    int* numOutLinks = (int*)malloc(sizeof(cl_int) * numNodes);
    
    while(!infile.eof()) // To get you all the lines.
    {
        getline(infile,STRING); // Saves the line in STRING.
        stringstream stream(STRING);
        stream >> source;
        stream >> des;
        destination2 = -1;
        if (source > numNodes) {
            break;
        }
        
        while(stream){
            stream>>destination;
            if (destination != destination2) {
                destination2 = destination;
                numOutLinks[source-1]++;
                if (destination > numNodes) {
                    continue;
                }
                adjM[destination-1].push_back(source-1);
                //cout<<adjM[0][0] << " "<< source << ' ' << destination <<endl;
                numEdges++;
            }
        }
    }
    
    // First, try to obtain a dispatch queue that can send work to the
    // GPU in our system. // 2
    dispatch_queue_t queue =
    gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, NULL);
    // In the event that our system does NOT have an OpenCL-compatible GPU,
    // we can use the OpenCL CPU compute device instead.
    if (queue == NULL) {
        queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_CPU, NULL);
    }
    
    int k = 10; // number of iterations
    float d = 0.85; // damping factor
    
    int curOffset = 0;
    int* pointers = (int*)malloc(sizeof(cl_int) * numNodes * 2);
    int* inlinks = (int*)malloc(sizeof(cl_int) * numEdges);
    for (int i = 0; i < numNodes; ++i) {
        pointers[2 * i] = curOffset;
        for (int j = 0; j < adjM[i].size(); ++j) {
            inlinks[curOffset + j] = adjM[i][j];
        }
        curOffset += adjM[i].size();
        pointers[2 * i + 1] = curOffset;
    }
    
    
    float* oldpr = (float*)malloc(sizeof(cl_float) * numNodes);
    float* newpr = (float*)malloc(sizeof(cl_float) * numNodes);
    float initPR = 1 / (float)numNodes;
    float constPart = (1 - d) / numNodes;
    printf("const part is %f\n", constPart);
    for (int i = 0; i < numNodes; ++i) {
        oldpr[i] = (cl_float)initPR;
        newpr[i] = constPart;
    }
    
    clock_t t = clock();
    
    void* gcl_oldpr = gcl_malloc(sizeof(cl_float) * numNodes, NULL,
                                 CL_MEM_READ_ONLY);
    void* gcl_newpr = gcl_malloc(sizeof(cl_float) * numNodes, oldpr,
                                 CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    
    void* gcl_inlinks = gcl_malloc(sizeof(cl_int) * numEdges, inlinks,
                                   CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    void* gcl_numOutlinks = gcl_malloc(sizeof(cl_int) * numNodes, numOutLinks,
                                   CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    
    void* gcl_pointers = gcl_malloc(sizeof(cl_int) * 2 * numNodes, pointers, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    
    // Dispatch the kernel block using one of the dispatch_ commands and the
    // queue created earlier. // 5
    dispatch_sync(queue, ^{
        // Although we could pass NULL as the workgroup size, which would tell
        // OpenCL to pick the one it thinks is best, we can also ask
        // OpenCL for the suggested size, and pass it ourselves.
        size_t wgs;
        gcl_get_kernel_block_workgroup_info(pagerank_kernel,
                                            CL_KERNEL_WORK_GROUP_SIZE,
                                            sizeof(wgs), &wgs, NULL);
        printf("work group size %d \n", (int)wgs);
        
        // The N-Dimensional Range over which we'd like to execute our
        // kernel. In this case, we're operating on a 1D buffer, so
        // it makes sense that the range is 1D.
        cl_ndrange range1 = { // 6
            1, // The number of dimensions to use.
            {0, 0, 0}, // The offset in each dimension. To specify
            // that all the data is processed, this is 0
            // in the test case. // 7
            {static_cast<size_t>(numNodes), 0, 0}, // The global range—this is how many items
            // IN TOTAL in each dimension you want to
            // process.
            {NULL, 0, 0} // The local size of each workgroup. This
            // determines the number of work items per
            // workgroup. It indirectly affects the
            // number of workgroups, since the global
            // size / local size yields the number of
            // workgroups. In this test case, there are
            // NUM_VALUE / wgs workgroups.
        };
        
        cl_ndrange range2 = { // 6
            1, // The number of dimensions to use.
            {0, 0, 0}, // The offset in each dimension. To specify
            // that all the data is processed, this is 0
            // in the test case. // 7
            {static_cast<size_t>(numNodes), 0, 0}, // The global range—this is how many items
            // IN TOTAL in each dimension you want to
            // process.
            {NULL, 0, 0} // The local size of each workgroup. This
            // determines the number of work items per
            // workgroup. It indirectly affects the
            // number of workgroups, since the global
            // size / local size yields the number of
            // workgroups. In this test case, there are
            // NUM_VALUE / wgs workgroups.
        };
        
        // Calling the kernel is easy; simply call it like a function,
        // passing the ndrange as the first parameter, followed by the expected
        // kernel parameters. Note that we case the 'void*' here to the
        // expected OpenCL types. Remember, a 'float' in the
        // kernel, is a 'cl_float' from the application's perspective. // 8

        exchange_kernel(&range2, (cl_float*)gcl_oldpr, (cl_float*)gcl_newpr, (cl_int*)gcl_numOutlinks);
        gcl_memcpy(newpr, gcl_newpr, sizeof(cl_float) * numNodes);
        gcl_memcpy(oldpr, gcl_oldpr, sizeof(cl_float) * numNodes);
        for (int i = 0; i < numNodes; ++i) {
//            printf("%f\n", newpr[i]);
        }
        
        for (int i = 0; i < k - 1; ++i) {
//            clock_t t1 = clock();
            pagerank_kernel(&range1, (cl_int*)gcl_pointers, (cl_int*)gcl_inlinks, (cl_float*)gcl_oldpr, (cl_float*)gcl_newpr);
//            t1 = clock() - t1;
//            double time_taken = ((double)t1)/CLOCKS_PER_SEC; // in seconds
//            printf("pagerank() took %f seconds to execute \n", time_taken);
            
//            clock_t t2 = clock();
            exchange_kernel(&range2, (cl_float*)gcl_oldpr, (cl_float*)gcl_newpr, (cl_int*)gcl_numOutlinks);
//            t2 = clock() - t2;
//            time_taken = ((double)t2)/CLOCKS_PER_SEC; // in seconds
//            printf("copy took %f seconds to execute \n", time_taken);
        }
        
        // kth iteration
        pagerank_kernel(&range1, (cl_int*)gcl_pointers, (cl_int*)gcl_inlinks, (cl_float*)gcl_oldpr, (cl_float*)gcl_newpr);
        gcl_memcpy(newpr, gcl_newpr, sizeof(cl_float) * numNodes);
        
        // Getting data out of the device's memory space is also easy;
        // use gcl_memcpy. In this case, gcl_memcpy takes the output
        // computed by the kernel and copies it over to the
        // application's memory space. // 9
//        gcl_memcpy(test_out, mem_out, sizeof(cl_float) * NUM_VALUES);
    });
    
//    for (int i = 0; i < numNodes; ++i) {
//        printf("node %d %f\n", i, newpr[i]);
//    }
    
    printf("node %e\n", newpr[0]);
    printf("node %e\n", newpr[1]);
    printf("node %e\n", newpr[2]);
    printf("node %e\n", newpr[3]);
    printf("node %e\n", newpr[4]);
    
    
    free(numOutLinks);
    free(inlinks);
    free(oldpr);
    free(newpr);
    
    // Don't forget to free up the CL device's memory when you're done. // 10
    gcl_free(gcl_newpr);
    gcl_free(gcl_oldpr);
    gcl_free(gcl_inlinks);
    gcl_free(gcl_numOutlinks);
    
    // And the same goes for system memory, as usual.
    // Finally, release your queue just as you would any GCD queue. // 11
    dispatch_release(queue);
    
    t = clock() - t;
    double time_taken = ((double)t)/CLOCKS_PER_SEC; // in seconds
    printf("overall time %f\n", time_taken);
}
