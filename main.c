#include <stdio.h>
#include <stdlib.h>
// This include pulls in everything you need to develop with OpenCL in OS X.
#include <OpenCL/opencl.h>
// Include the header file generated by Xcode. This header file contains the
// kernel block declaration. // 1
#include "mykernel.cl.h"
// Hard-coded number of values to test, for convenience.

int main (int argc, const char * argv[]) {
    int k = 10; // number of iterations
    
    int i;
    FILE *data;
    data = fopen("/Users/yixing/Desktop/hollins.dat", "r");
    if (!data) {
        fprintf(stderr, "cannot open datafile\n");
        return 1;
    }
    
    int numNodes, numEdges;
    fscanf(data, "%d %d", &numNodes, &numEdges);
    
    int* numOutLinks = (int*)malloc(sizeof(cl_int) * numNodes);
    int* inlinks = (int*)malloc(sizeof(cl_int) * numEdges);
    int* outlinks = (int*)malloc(sizeof(cl_int) * numEdges);
    int in, out;
    for (int i = 0; i < numEdges; ++i) {
        if(fscanf(data, "%d %d", &in, &out) != EOF) {
            // in and out starts from 1
            // change to let them start from 0
            --in; --out;
            inlinks[i] = (cl_int)in;
            outlinks[i] = (cl_int)out;
            ++numOutLinks[in];
        }
    }
    fclose(data);
    
//  test reading is correct
//    printf("%d\n", numOutLinks[6004]);
//    for (int i = 0; i < numEdges; ++i) {
//        printf("%d %d\n", inlinks[i], outlinks[i]);
//    }
    
    char name[128];
    // First, try to obtain a dispatch queue that can send work to the
    // GPU in our system. // 2
    dispatch_queue_t queue =
    gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, NULL);
    // In the event that our system does NOT have an OpenCL-compatible GPU,
    // we can use the OpenCL CPU compute device instead.
    if (queue == NULL) {
        queue = gcl_create_dispatch_queue(CL_DEVICE_TYPE_CPU, NULL);
    }
    // This is not required, but let's print out the name of the device
    // we are using to do work. We could use the same function,
    // clGetDeviceInfo, to obtain all manner of information about the device.
    cl_device_id gpu = gcl_get_device_id_with_dispatch_queue(queue);
    clGetDeviceInfo(gpu, CL_DEVICE_NAME, 128, name, NULL);
    fprintf(stdout, "Created a dispatch queue using the %s\n", name);
    
    
    float* oldpr = (float*)malloc(sizeof(cl_float) * numNodes);
    float* newpr = (float*)malloc(sizeof(cl_float) * numNodes);
    float initPR = 1 / (float)numNodes;
    for (int i = 0; i < numNodes; ++i) {
        oldpr[i] = (cl_float)initPR;
        newpr[i] = 0;
    }
    
    void* gcl_oldpr = gcl_malloc(sizeof(cl_float) * numNodes, oldpr,
                                 CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    void* gcl_newpr = gcl_malloc(sizeof(cl_float) * numNodes, newpr,
                                 CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    void* gcl_inlinks = gcl_malloc(sizeof(cl_int) * numEdges, inlinks,
                                   CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    void* gcl_outlinks = gcl_malloc(sizeof(cl_int) * numEdges, outlinks,
                                   CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    void* gcl_numOutlinks = gcl_malloc(sizeof(cl_int) * numNodes, numOutLinks,
                                   CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
    
    // Dispatch the kernel block using one of the dispatch_ commands and the
    // queue created earlier. // 5
    dispatch_sync(queue, ^{
        // Although we could pass NULL as the workgroup size, which would tell
        // OpenCL to pick the one it thinks is best, we can also ask
        // OpenCL for the suggested size, and pass it ourselves.
//        size_t wgs;
//        gcl_get_kernel_block_workgroup_info(square_kernel,
//                                            CL_KERNEL_WORK_GROUP_SIZE,
//                                            sizeof(wgs), &wgs, NULL);
        // The N-Dimensional Range over which we'd like to execute our
        // kernel. In this case, we're operating on a 1D buffer, so
        // it makes sense that the range is 1D.
        cl_ndrange range = { // 6
            1, // The number of dimensions to use.
            {0, 0, 0}, // The offset in each dimension. To specify
            // that all the data is processed, this is 0
            // in the test case. // 7
            {numEdges, 0, 0}, // The global rangeâ€”this is how many items
            // IN TOTAL in each dimension you want to
            // process.
            {NULL, 0, 0} // The local size of each workgroup. This
            // determines the number of work items per
            // workgroup. It indirectly affects the
            // number of workgroups, since the global
            // size / local size yields the number of
            // workgroups. In this test case, there are
            // NUM_VALUE / wgs workgroups.
        };
        // Calling the kernel is easy; simply call it like a function,
        // passing the ndrange as the first parameter, followed by the expected
        // kernel parameters. Note that we case the 'void*' here to the
        // expected OpenCL types. Remember, a 'float' in the
        // kernel, is a 'cl_float' from the application's perspective. // 8
        
        for (int i = 0; i < k; ++i) {
            square_kernel(&range,(cl_float*)mem_in, (cl_float*)mem_out);
            gcl_memcpy(mem_in, mem_out, sizeof(cl_float) * NUM_VALUES);
        }
        
        // Getting data out of the device's memory space is also easy;
        // use gcl_memcpy. In this case, gcl_memcpy takes the output
        // computed by the kernel and copies it over to the
        // application's memory space. // 9
        gcl_memcpy(test_out, mem_out, sizeof(cl_float) * NUM_VALUES);
    });
    
    free(numOutLinks);
    free(inlinks);
    free(outlinks);
    free(oldpr);
    free(newpr);
    
    // Don't forget to free up the CL device's memory when you're done. // 10
    gcl_free(gcl_newpr);
    gcl_free(gcl_oldpr);
    gcl_free(gcl_inlinks);
    gcl_free(gcl_outlinks);
    gcl_free(gcl_numOutlinks);
    
    // And the same goes for system memory, as usual.
    // Finally, release your queue just as you would any GCD queue. // 11
    dispatch_release(queue);
}
